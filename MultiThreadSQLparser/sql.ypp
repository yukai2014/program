/*
 *
 * 14.02.15 已有select语句和create语句，包括select语句连接系统所需的函数
 *
 */

/* Companion source code for "flex & bison", published by O'Reilly
 * Media, ISBN 978-0-596-15597-1
 * Copyright (c) 2009, Taughannock Networks. All rights reserved.
 * See the README file for license conditions and contact info.
 * $Header: /home/johnl/flnb/code/sql/RCS/glrmysql.y,v 2.1 2009/11/08 02:53:39 johnl Exp $
 */
/*
 * Parser for mysql subset, GLR version
 */
 

%glr-parser%expect 7
%expect-rr 79

%defines

%{
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <iostream>
#include <stdio.h>
#include <malloc.h>
#include <pthread.h>
#include "sql_node_struct.h"
using namespace std;

Node * parsetreeroot;
char globalInputText[10000];
extern int numToRead;
extern pthread_mutex_t mutex;
%}


%union {
	int intval;
	double floatval;
	char *strval;
	int subtok;
	struct Node * ast_node;
}
	
	/* names and literal values */

%token <strval> NAME
%token <strval> STRING
%token <intval> INTNUM
%token <intval> BOOL
%token <floatval> APPROXNUM

       /* user @abc names */

%token <strval> USERVAR

	/* operators and precedence levels */

%right ASSIGN
%left OR
%left XOR
%left ANDOP
%nonassoc IN IS LIKE REGEXP
%left NOT '!'
%left BETWEEN
%left <subtok> COMPARISON /* = <> < > <= >= <=> */
%left '|'
%left '&'
%left <subtok> SHIFT /* << >> */
%left '+' '-'
%left '*' '/' '%' MOD
%left '^'
%nonassoc UMINUS

%token ADD
%token ALL
%token ALTER
%token ANALYZE
%token AND
%token ANY
%token AS
%token ASC
%token AUTO_INCREMENT
%token BEFORE
%token BETWEEN
%token BIGINT
%token BINARY
%token BIT
%token BLOB
%token BOTH
%token BY
%token CALL
%token CASCADE
%token CASE
%token CHANGE
%token CHAR
%token CHECK
%token COLLATE
%token COLUMN
%token COMMENT
%token CONDITION
%token CONSTRAINT
%token CONTINUE
%token CONVERT
%token CREATE
%token CROSS
%token CURRENT_DATE
%token CURRENT_TIME
%token CURRENT_TIMESTAMP
%token CURRENT_USER
%token CURSOR
%token DATABASE
%token DATABASES
%token DATE
%token DATETIME
%token DAY_HOUR
%token DAY_MICROSECOND
%token DAY_MINUTE
%token DAY_SECOND
%token DECIMAL
%token DECLARE
%token DEFAULT
%token DELAYED
%token DELETE
%token DESC
%token DESCRIBE
%token DETERMINISTIC
%token DISTINCT
%token DISTINCTROW
%token DIV
%token DOUBLE
%token DROP
%token DUAL
%token EACH
%token ELSE
%token ELSEIF
%token ENCLOSED
%token END
%token ENUM
%token ESCAPED
%token EXISTS
%token EXIT
%token EXPLAIN
%token FETCH
%token FLOAT
%token FOR
%token FORCE
%token FOREIGN
%token FROM
%token FULLTEXT
%token GRANT
%token GROUP
%token HAVING
%token HIGH_PRIORITY
%token HOUR_MICROSECOND
%token HOUR_MINUTE
%token HOUR_SECOND
%token IF
%token IGNORE
%token IN
%token INDEX
%token INFILE
%token INNER
%token INOUT
%token INSENSITIVE
%token INSERT
%token INT
%token INTEGER
%token INTERVAL
%token INTO
%token ITERATE
%token JOIN
%token KEY
%token KEYS
%token KILL
%token LEADING
%token LEAVE
%token LEFT
%token LIKE
%token LIMIT
%token LINES
%token LOAD
%token LOCALTIME
%token LOCALTIMESTAMP
%token LOCK
%token LONG
%token LONGBLOB
%token LONGTEXT
%token LOOP
%token LOW_PRIORITY
%token MATCH
%token MEDIUMBLOB
%token MEDIUMINT
%token MEDIUMTEXT
%token MINUTE_MICROSECOND
%token MINUTE_SECOND
%token MOD
%token MODIFIES
%token NATURAL
%token NOT
%token NO_WRITE_TO_BINLOG
%token NULLX
%token NUMBER
%token ON
%token DUPLICATE
%token OPTIMIZE
%token OPTION
%token OPTIONALLY
%token OR
%token ORDER
%token OUT
%token OUTER
%token OUTFILE
%token PRECISION
%token PRIMARY
%token PROCEDURE
%token PURGE
%token QUICK
%token READ
%token READS
%token REAL
%token REFERENCES
%token REGEXP
%token RELEASE
%token RENAME
%token REPEAT
%token REPLACE
%token REQUIRE
%token RESTRICT
%token RETURN
%token REVOKE
%token RIGHT
%token ROLLUP
%token SCHEMA
%token SCHEMAS
%token SECOND_MICROSECOND
%token SELECT
%token SENSITIVE
%token SEPARATOR
%token SET
%token SHOW
%token SMALLINT
%token SOME
%token SONAME
%token SPATIAL
%token SPECIFIC
%token SQL
%token SQLEXCEPTION
%token SQLSTATE
%token SQLWARNING
%token SQL_BIG_RESULT
%token SQL_CALC_FOUND_ROWS
%token SQL_SMALL_RESULT
%token SSL
%token STARTING
%token STRAIGHT_JOIN
%token TABLE
%token TEMPORARY
%token TEXT
%token TERMINATED
%token THEN
%token TIME
%token TIMESTAMP
%token TINYBLOB
%token TINYINT
%token TINYTEXT
%token TO
%token TRAILING
%token TRIGGER
%token UNDO
%token UNION
%token UNIQUE
%token UNLOCK
%token UNSIGNED
%token UPDATE
%token USAGE
%token USE
%token USING
%token UTC_DATE
%token UTC_TIME
%token UTC_TIMESTAMP
%token VALUES
%token VARBINARY
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE
%token WHILE
%token WITH
%token WRITE
%token XOR
%token YEAR
%token YEAR_MONTH
%token ZEROFILL

/** added by yukai **/
%token DO
%token MAX_QUERIES_PER_HOUR
%token MAX_UPDATES_PER_HOUR
%token MAX_CONNECTIONS_PER_HOUR
%token MAX_USER_CONNECTIONS
%token USER
%token TRUNCATE
%token FAST
%token MEDIUM
%token EXTENDED
%token CHANGED
%token LEAVES
%token MASTER
%token QUERY CACHE
%token SLAVE
%token BEGINT
%token COMMIT
%token START
%token TRANSACTION
%token NO
%token CHAIN
%token AUTOCOMMIT
%token SAVEPOINT
%token ROLLBACK
%token LOCAL
%token TABLES
%token ISOLATION
%token LEVEL
%token GLOBAL
%token SESSION
%token UNCOMMITTED
%token COMMITTED
%token REPEATABLE
%token SERIALIZABLE
%token IDENTIFIED
%token PASSWORD
%token PRIVILEGES
%token BACKUP
%token CHECKSUM
%token REPAIR
%token USE_FRM
%token RESTORE
%token CHARACTER
%token COLLATION
%token COLUMNS
%token ENGINE
%token LOGS
%token STATUS
%token STORAGE 
%token ENGINES
%token ERRORS
%token GRANTS
%token INNODB
%token PROCESSLIST
%token TRIGGERS
%token VARIABLES
%token WARNINGS
%token FLUSH
%token HOSTS
%token DES_KEY_FILE
%token USER_RESOURCES
%token CONNECTION
%token RESET
%token PREPARE
%token DEALLOCATE
%token EXECUTE
%token WORK
%token BTREE
%token HASH
%token BDB
%token OPEN
%token FULL

 /* functions with special syntax */
%token FSUBSTRING
%token FTRIM
%token FDATE_ADD FDATE_SUB
%token FCOUNT
  
/**********/


%type <intval> select_opts opt_with_rollup opt_asc_desc opt_inner_cross left_or_right 
%type <intval> opt_left_or_right_outer opt_outer  insert_opts
%type <strval>  opt_as_alias  
%type <ast_node> stmt_list
%type <ast_node> select_expr_list opt_where select_stmt stmt opt_groupby select_expr
%type <ast_node> expr_list opt_expr_list  case_list  opt_having opt_orderby expr
%type <ast_node> groupby_list opt_limit table_reference table_factor
%type <ast_node> table_references   opt_into_list opt_join_condition join_condition
%type <ast_node> column_list  table_subquery  join_table
%type <ast_node> index_list opt_for_join opt_col_names
%type <ast_node> delete_opts delete_list 
%type <ast_node> insert_vals insert_vals_list
%type <ast_node> insert_asgn_list  update_opts update_asgn_list
%type <ast_node>  opt_length  enum_list
%type <ast_node> column_atts create_col_list

/** add by yukai **/
%type <ast_node> create_database_stmt create_table_stmt  create_select_statement
%type <ast_node> create_definition alter_database_stmt alter_table_stmt opt_csc
%type <ast_node> alter_noduplicate_definition alter_definition data_type
%type <ast_node> truncate_stmt
%type <intval> table_list opt_rc  opt_ignore opt_if_exists
%type <intval> opt_col index_att index_type rename_list
%type <intval> opt_chain opt_release opt_read_write
%type <intval> opt_trans_level trans_att priv_database_type priv_table_type
%type <intval> analyze_opt check_opts checksum_opt repair_opts opt_full
%type <intval> opt_index_key flush_opt flush_opt_list opt_connection_query
%type <intval> reset_opt reset_opt_list opt_ignore_replace opt_if_not_exists
%type <intval> opt_temporary  opt_binary opt_uz

%start stmt_list

%%

stmt_list: stmt ';'		{ printf("> \n"); $$ = $1; parsetreeroot = $$; /*output($$, 1);*/ }
	| stmt_list stmt ';'	{ printf("> \n");/* $$ = $1;*/ parsetreeroot = $$; /*output($$, 1);*/ }
  	;

   /* statements: select statement */

stmt: select_stmt { $$=$1; output($$, 1); puts("This is a select statement"); }
	;

select_stmt: 
	SELECT select_opts select_expr_list
	{
		$$ = newQueryStmt(t_query_stmt, NULL, $2, $3, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		puts("select_stmt1");
	}
	| SELECT select_opts select_expr_list FROM table_references opt_where 
    			opt_groupby opt_having opt_orderby opt_limit opt_into_list 
		{
			$$ = newQueryStmt(t_query_stmt, NULL, $2, $3, $5, $6, $7, $8, $9, $10, $11);
			puts("select_stmt2");
		}		
	;

opt_where: /* nil */	{ $$= NULL; puts("opt_where is null"); }
	| WHERE expr 		{ $$ = newWhereList(t_where_list, NULL, $2); puts("opt_where");};

opt_groupby: /* nil */ { $$=NULL; puts("opt_groupby is null"); }
	| GROUP BY groupby_list opt_with_rollup
	{
     	$$ = newGroupbyList(t_groupby_list, NULL, $3, $4);
      	puts("opt_groupby");
	}
	;

groupby_list: expr opt_asc_desc
	{ 
		$$=newGroupbyExpr(t_groupby_expr, $1, $2, NULL);
		puts("groupby_list1");
	}
	| groupby_list ',' expr opt_asc_desc
    {
     	$$=newGroupbyExpr(t_groupby_expr, $3, $4, $1);
     	puts("groupby_list2");
    }
	;

opt_asc_desc: /* nil */ { $$ = 0; }
   | ASC                { $$ = 0; }
   | DESC               { $$ = 1; }
    ;

opt_with_rollup: /* nil */  { $$ = 0; }
   | WITH ROLLUP  { $$ = 1; }
   ;

opt_having: /* nil */ { $$=NULL; puts("opt_having is null"); }
	| HAVING expr 
	{
		$$=newHavingList(t_having_list, NULL, $2);
		puts("opt_having2");
	}
	;

opt_orderby: /* nil */ { $$=NULL; puts("opt_orederby is null"); }
	| ORDER BY groupby_list 
	{
		$$=newOrderbyList(t_groupby_list, NULL, $3);
		puts("opt_orederby2");
	}
	;

opt_limit: /* nil */ {$$ = NULL; puts("opt_limit is null");}
	| LIMIT expr
	{
		$$=newLimitExpr(t_limit_expr, NULL, $2);
		puts("opt_limit2");
	}
  	| LIMIT expr ',' expr
  	{
  		Limit_expr *n=(Limit_expr *)malloc(sizeof(struct Limit_expr));
  		n->type=t_limit_expr;
  		n->offset=$2;
  		n->row_count=$4;
		$$=(Node *)n;
	}
	; 

opt_into_list: /* nil */ { $$=NULL; puts("opt_into_list is null"); }//no
   | INTO column_list {  }
   ;

column_list: NAME { $$ = newColumn(t_column, $1, NULL, NULL); }
  | column_list ',' NAME { $$ = newColumn(t_column, $3, NULL, $1); }
  ;

select_opts:                      { $$ = 0; }
| select_opts ALL                 { if($$ & 1) yyerror("duplicate ALL option"); $$ = $1 | 1; }
| select_opts DISTINCT            { if($$ & 2) yyerror("duplicate DISTINCT option"); $$ = $1 | 2; }
| select_opts DISTINCTROW         { if($$ & 4) yyerror("duplicate DISTINCTROW option"); $$ = $1 | 4; }
| select_opts HIGH_PRIORITY       { if($$ & 8) yyerror("duplicate HIGH_PRIORITY option"); $$ = $1 | 8; }
| select_opts STRAIGHT_JOIN       { if($$ & 16) yyerror("duplicate STRAIGHT_JOIN option"); $$ = $1 | 16; }
| select_opts SQL_SMALL_RESULT    { if($$ & 32) yyerror("duplicate SQL_SMALL_RESULT option"); $$ = $1 | 32; }
| select_opts SQL_BIG_RESULT      { if($$ & 64) yyerror("duplicate SQL_BIG_RESULT option"); $$ = $1 | 64; }
| select_opts SQL_CALC_FOUND_ROWS { if($$ & 128) yyerror("duplicate SQL_CALC_FOUND_ROWS option"); $$ = $1 | 128; }
    ;

select_expr_list: select_expr			{ $$ = newSelectList(t_select_list, 0, $1, NULL); puts("select_expr_list1"); }
    | select_expr_list ',' select_expr	{ $$ = newSelectList(t_select_list, 0, $3, $1); puts("select_expr_list2"); }
    | '*'	{ $$ = newSelectList(t_select_list, 1, NULL, NULL); puts("select_expr_list3"); }
    ;

select_expr: expr opt_as_alias	{ $$ = newSelectExpr(t_select_expr, $2, $1); puts("select_expr"); }
	;

table_references: table_reference			{ $$=newFromList(t_from_list, $1, NULL, NULL); puts("table_references1"); }
    | table_references ',' table_reference	{ $$=newFromList(t_from_list, $3, $1, NULL); puts("table_references2"); }
    ;

table_reference:  table_factor { $$=$1;puts("table_referen1"); }
  	| join_table { $$=$1;puts("table_referen2");}
	;

table_factor:
    NAME opt_as_alias/* index_hint */
    {
	    $$=newTable(t_table, NULL,$1, $2, 0, NULL, NULL);
	    puts("table_factor1");
    }
  	| NAME '.' NAME opt_as_alias /*index_hint*/ 
  	{
		$$=newTable(t_table, $1, $3, $4, 0, NULL, NULL);
   		puts("table_factor2");}
  	| table_subquery opt_as NAME 
  	{
		$$=newTable(t_table, NULL, NULL, $3, 1, $1, NULL);
		puts("table_factor3");
	}
	| '(' table_references ')' { $$=$2; }
  	;

opt_as: /* nil */
  | AS 
  ;

opt_as_alias: AS NAME { $$=$2; puts("opt_as_alias1");}
  | NAME              { $$=$1; puts("opt_as_alias2");}
  | /* nil */         { $$=NULL; puts("opt_as_alias3");}
  ;

/*
inner 1
cross 2
outer 4
left 8
right 16
nature 32
straight_join -1
*/


join_table:// 枚举不同的制约参数
	table_reference opt_inner_cross JOIN table_factor opt_join_condition
	{
		$$=newJoin(t_join, $2, $1, $4, $5);
	}              
	| table_reference STRAIGHT_JOIN table_factor 
	{
		$$=newJoin(t_join, -1, $1, $3, NULL);
	}
	| table_reference STRAIGHT_JOIN table_factor ON expr  
	{
		Node *m=newCondition(t_condition, 1, $5);
		$$=newJoin(t_join, -1, $1, $3, m);
	}
  	| table_reference left_or_right opt_outer JOIN table_factor join_condition
    {
		$$=newJoin(t_join, $2+$3, $1, $5, $6);
    }
  	| table_reference NATURAL opt_left_or_right_outer JOIN table_factor
	{
		$$=newJoin(t_join, 32 + $3, $1, $5, NULL);
	}
  	;

opt_inner_cross: /* nil */ { $$ = 0; }
   	| INNER	{ $$ = 1; }
   	| CROSS	{ $$ = 2; }
	;

opt_outer: /* nil */{ $$ = 0; }
	| OUTER	{$$ = 4; }
   	;

left_or_right: LEFT	{ $$ = 8; }
    | RIGHT { $$ = 16; }
    ;

opt_left_or_right_outer: LEFT opt_outer	{ $$ = 8 + $2; }
	| RIGHT opt_outer  { $$ = 16 + $2; }
	| /* nil */ { $$ = 0; }
	;

opt_join_condition: /* nil */
	| join_condition	{$$=$1;}
	;
/*
on 1
using 2
*/

join_condition: ON expr 
    {
    	$$=newCondition(t_condition, 1, $2);
    }
    | USING '(' column_list ')' 
    {
    	$$=newCondition(t_condition, 2, $3);
    }
    ;

index_hint://暂时没有考虑
     USE KEY opt_for_join '(' index_list ')'
                  {  }
   | IGNORE KEY opt_for_join '(' index_list ')'
                  { }
   | FORCE KEY opt_for_join '(' index_list ')'
                  {  }
   | /* nil */
   ;

opt_for_join: FOR JOIN { $$ = 1; }//no
   | /* nil */ { $$ = 0; }//no
   ;

index_list: NAME  { emit("INDEX %s", $1);  }////////////////////////////////////////////////////////////////////////////////
   | index_list ',' NAME { emit("INDEX %s", $3); }//////////////////////////////////////////////////////////////////////////
   ;

table_subquery: '(' select_stmt ')' {  }
   ;

   /* statements: delete statement */

stmt: delete_stmt { emit("STMT"); }
   ;

delete_stmt: DELETE delete_opts FROM NAME
    opt_where opt_orderby opt_limit
                  { emit("DELETEONE %d %s", $2, $4); free($4); }
;

delete_opts: delete_opts LOW_PRIORITY { $$ = $1 + 01; }
   | delete_opts QUICK { $$ = $1 + 02; }
   | delete_opts IGNORE { $$ = $1 + 04; }
   | /* nil */ { $$ = 0; }
   ;

delete_stmt: DELETE delete_opts
    delete_list
    FROM table_references opt_where
            {  }
;
delete_list: NAME opt_dot_star {  }
   | delete_list ',' NAME opt_dot_star {  }
   ;

opt_dot_star: /* nil */ 
   | '.' '*' 
   ;

delete_stmt: DELETE delete_opts FROM delete_list USING table_references opt_where
   { emit("DELETEMULTI %d %d %d", $2, $4, $6); }
   ;

   /* statements: insert statement */

stmt: insert_stmt { emit("STMT"); }
   ;

insert_stmt: INSERT insert_opts opt_into NAME
     opt_col_names
     VALUES insert_vals_list
     opt_ondupupdate { emit("INSERTVALS %d %d %s", $2, $7, $4); free($4) }
   ;

opt_ondupupdate: /* nil */
   | ON DUPLICATE KEY UPDATE insert_asgn_list { emit("DUPUPDATE %d", $5); }
   ;

insert_opts: /* nil */			{ $$ = 0; }
   | insert_opts LOW_PRIORITY	{ $$ = $1 | 01 ; }
   | insert_opts DELAYED 		{ $$ = $1 | 02 ; }
   | insert_opts HIGH_PRIORITY  { $$ = $1 | 04 ; }
   | insert_opts IGNORE			{ $$ = $1 | 010 ; }
   ;

opt_into: INTO | /* nil */
	;

opt_col_names: /* nil */
   | '(' column_list ')' {  }
   ;

insert_vals_list: '(' insert_vals ')' /*{ emit("VALUES %d", $2); }*/
   | insert_vals_list ',' '(' insert_vals ')' /*{ emit("VALUES %d", $4);}*/
;
insert_vals:
     expr //{ $$ = 1; }
   | DEFAULT// { emit("DEFAULT"); $$ = 1; }
   | insert_vals ',' expr //{ $$ = $1 + 1; }
   | insert_vals ',' DEFAULT //{ emit("DE//没什么用，因为limit只有一项FAULT"); $$ = $1 + 1; }
   ;

insert_stmt: INSERT insert_opts opt_into NAME
    SET insert_asgn_list
    opt_ondupupdate
     { emit("INSERTASGN %d %d %s", $2, $6, $4); free($4) }
   ;

insert_stmt: INSERT insert_opts opt_into NAME opt_col_names
    select_stmt
    opt_ondupupdate { emit("INSERTSELECT %d %s", $2, $4); free($4); }
  ;

insert_asgn_list:
     NAME COMPARISON expr 
    // { if ($2 != 4) yyerror("bad insert assignment to %s", $1);
     //  emit("ASSIGN %s", $1); free($1); $$ = 1; }
   | NAME COMPARISON DEFAULT
               //{ if ($2 != 4) yyerror("bad insert assignment to %s", $1);
              //   emit("DEFAULT"); emit("ASSIGN %s", $1); free($1); $$ = 1; }
   | insert_asgn_list ',' NAME COMPARISON expr
              // { if ($4 != 4) yyerror("bad insert assignment to %s", $1);
             //    emit("ASSIGN %s", $3); free($3); $$ = $1 + 1; }
   | insert_asgn_list ',' NAME COMPARISON DEFAULT
             //  { if ($4 != 4) yyerror("bad insert assignment to %s", $1);
             //    emit("DEFAULT"); emit("ASSIGN %s", $3); free($3); $$ = $1 + 1; }
   ;

   /** replace just like insert **/
stmt: replace_stmt { emit("STMT"); }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME
     opt_col_names
     VALUES insert_vals_list
     opt_ondupupdate { emit("REPLACEVALS %d %d %s", $2, $7, $4); free($4) }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME
    SET insert_asgn_list
    opt_ondupupdate
     { emit("REPLACEASGN %d %d %s", $2, $6, $4); free($4) }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME opt_col_names
    select_stmt
    opt_ondupupdate { emit("REPLACESELECT %d %s", $2, $4); free($4); }
  ;

/** update **/
stmt: update_stmt { emit("STMT"); }
   ;

update_stmt: UPDATE update_opts table_references
    SET update_asgn_list
    opt_where
    opt_orderby
opt_limit { emit("UPDATE %d %d %d", $2, $3, $5); }
;

update_opts: /* nil */ //{ $$ = 0; }
   | insert_opts LOW_PRIORITY //{ $$ = $1 | 01 ; }
   | insert_opts IGNORE //{ $$ = $1 | 010 ; }
   ;

update_asgn_list:
	NAME COMPARISON expr 
	{
		/*
		if ($2 != 4 || $3->data.string_val == NULL) 
			yyerror("bad insert assignment to %s", $1);
	 	emit("ASSIGN %s", $1); 
	 	free($3); 
	 	$$ = $3->data.string_val;
	 	*/ 
	}
	| NAME '.' NAME COMPARISON expr 
	{ 
	/*
		if ($4 != 4) 
			yyerror("bad insert assignment to %s", $1); 
		emit("ASSIGN %s.%s", $1, $3);
		free($1); 
		free($3); 
		$$ = 1;
	*/
	}
	| update_asgn_list ',' NAME COMPARISON expr
	//     { if ($4 != 4) yyerror("bad insert assignment to %s", $3); emit("ASSIGN %s.%s", $3); free($3); $$ = $1 + 1; }
	| update_asgn_list ',' NAME '.' NAME COMPARISON expr
	//     { if ($6 != 4) yyerror("bad insert assignment to %s.$s", $3, $5); 
	//		emit("ASSIGN %s.%s", $3, $5); free($3); free($5); $$ = 1;
	//		}
	;


   /** create database **/

stmt: create_database_stmt { $$=$1; output($$, 1); puts("This is a create_database statement"); }
   ;

create_database_stmt: 
	CREATE DATABASE opt_if_not_exists NAME 
		{ $$ =  newCreateDatabaseStmt(t_create_database_stmt, 1, $3, $4); }
	| CREATE SCHEMA opt_if_not_exists NAME 
		{ $$ =  newCreateDatabaseStmt(t_create_database_stmt, 2, $3, $4); }
	;

opt_if_not_exists:  /* nil */ { $$ = 0; } 
   | IF NOT EXISTS            { $$ = 1; } 
   ;

   /** create table **/
   
stmt: create_table_stmt { $$=$1; output($$, 1); puts("This is a create_table statement"); }
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
	'(' create_col_list ')'  { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, NULL, $7, NULL); }
	;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   '(' create_col_list ')' { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, $7, $9, NULL); }
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   '(' create_col_list ')' create_select_statement 
   { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, NULL, $7, $9); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   create_select_statement { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, NULL, NULL, $6); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   '(' create_col_list ')' create_select_statement  
   { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, $7, $9, $11); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
	create_select_statement 
	{ $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, $7, NULL, $8); }
	;

	
create_select_statement: opt_ignore_replace opt_as select_stmt 
	{ $$ = newCreateSelectStmt(t_create_select_stmt, $1, 0, $3); }
	;

opt_ignore_replace: /* nil */	{ $$ = 0; }
	| IGNORE		{ $$ = 1; }
	| REPLACE 		{ $$ = 2; }
	;

opt_temporary: /* nil */{ $$ = 0; }
	| TEMPORARY 		{ $$ = 1; }
	;

create_col_list: create_definition { $$ = newCreateColList(t_create_col_list, $1, NULL); }
	| create_col_list ',' create_definition { $$ = newCreateColList(t_create_col_list, $3, $1); }
	;

create_definition: 
    NAME data_type column_atts		{ $$ = newCreateDef( t_create_def, 1, $2, $3, NULL); }
    | PRIMARY KEY '(' column_list ')'	{ $$ = newCreateDef( t_create_def, 2, 0, NULL, $4); }
    | KEY '(' column_list ')'		{ $$ = newCreateDef( t_create_def, 3, 0, NULL, $3); }
    | INDEX '(' column_list ')'		{ $$ = newCreateDef( t_create_def, 4, 0, NULL, $3); }
    | FULLTEXT INDEX '(' column_list ')'{ $$ = newCreateDef( t_create_def, 5, 0, NULL, $4); }
    | FULLTEXT KEY '(' column_list ')'  { $$ = newCreateDef( t_create_def, 6, 0, NULL, $4); }
    ;

column_atts: /* nil */				{ $$ = newColumnAtts(t_column_atts, 0, 0, 0, NULL, NULL); }
    | column_atts NOT NULLX             	{ Column_atts *t = (Column_atts *)$1;t->datatype += 01; $$ = (Node *)t; }
    | column_atts NULLX				{ Column_atts *t = (Column_atts *)$1;t->datatype += 02; $$ = (Node *)t; }
    | column_atts DEFAULT STRING        	{  Column_atts *t = (Column_atts *)$1;t->datatype += 04; t->s = $3; $$ = (Node *)t; }
    | column_atts DEFAULT INTNUM		{  Column_atts *t = (Column_atts *)$1;t->datatype += 010; t->num1 = $3; $$ = (Node *)t; }
    | column_atts DEFAULT APPROXNUM     	{  Column_atts *t = (Column_atts *)$1;t->datatype += 020; t->num2 = $3; $$ = (Node *)t; }
    | column_atts DEFAULT BOOL          	{  Column_atts *t = (Column_atts *)$1;t->datatype += 040; t->num1 = $3; $$ = (Node *)t; }
    | column_atts AUTO_INCREMENT        	{  Column_atts *t = (Column_atts *)$1;t->datatype += 0100; $$ = (Node *)t; }
    | column_atts UNIQUE KEY 			{  Column_atts *t = (Column_atts *)$1;t->datatype += 0200; $$ = (Node *)t; }
    | column_atts PRIMARY KEY			{  Column_atts *t = (Column_atts *)$1;t->datatype += 0400; $$ = (Node *)t; }
    | column_atts KEY 				{  Column_atts *t = (Column_atts *)$1;t->datatype += 01000; $$ = (Node *)t; }
    | column_atts COMMENT STRING 		{  Column_atts *t = (Column_atts *)$1;t->datatype += 02000; $$ = (Node *)t; }
    | column_atts UNIQUE '(' column_list ')'	{  Column_atts *t = (Column_atts *)$1;t->datatype += 04000; t->col_list = $4; $$ = (Node *)t; }	
    ;
    
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** do expr **/
stmt: DO expr_list { $$ = newDoStmt(t_do_stmt,$2); puts("This is a do expr statement"); }
    ;
    
	/** truncate stmt **/
stmt: truncate_stmt { $$ = $1; puts("This is a truncate_stmt statement"); }
    ;
	
truncate_stmt: TRUNCATE NAME	{ $$ = newTruncateStmt(t_truncate_stmt, $2); }
    | TRUNCATE TABLE NAME	{ $$ = newTruncateStmt(t_truncate_stmt, $3); }
    ;

   /** alter database **/
stmt: alter_database_stmt { $$=$1; output($$, 1); puts("This is a alter_database statement"); }
	;

alter_database_stmt:
	ALTER DATABASE NAME opt_csc 	{ $$ = newAlterDBStmt(t_alter_database_stmt, 1, $3, $4); }	
   | ALTER SCHEMA NAME opt_csc		{ $$ = newAlterDBStmt(t_alter_database_stmt, 2, $3, $4); }
   ;
   
   /** alter table **/
stmt: alter_table_stmt { $$=$1; output($$, 1); puts("This is a alter_table statement"); }
	;
	
/*MySQL可以在一个ALTER TABLE语句里写入多个ADD, ALTER, DROP和CHANGE子句，中间用逗号分开*/   
alter_table_stmt: 
	ALTER opt_ignore TABLE NAME alter_definition { $$ = newAlterTableStmt(t_alter_table_stmt, $2, $4, $5); }
   | ALTER opt_ignore TABLE NAME alter_noduplicate_definition { $$ = newAlterTableStmt(t_alter_table_stmt, $2, $4, $5); }
   ;
   
alter_definition:
	alter_duplicate_definition
   | alter_definition ',' alter_duplicate_definition
   ;
   
alter_duplicate_definition: 
	ADD opt_col create_col_list {}
   | CHANGE opt_col NAME NAME data_type column_atts {}
   | DROP opt_col NAME 
   | DROP PRIMARY KEY
   | DROP INDEX column_list
   | DROP FOREIGN KEY column_list
   ;
   
opt_col: /* nil */ { $$ = 0; }
   | COLUMN { $$ = 1; }
   ;
   
alter_noduplicate_definition:
   | RENAME NAME {}
   | RENAME TO NAME {}
   | ORDER BY NAME
   ;
   
opt_ignore: /* nil */ { $$ = 0; }
   | IGNORE { $$ = 1; }
   ;
	
    /** create index **/
stmt: create_index_stmt { emit("STMT"); }
	;
	
create_index_stmt:
	CREATE index_att INDEX NAME opt_using_type ON NAME '(' index_col_list ')'
    ;
	
index_att: /* nil */ { $$ = 0;} 
   | UNIQUE 	{ $$ = 1; }
   | FULLTEXT	{ $$ = 2; }
   | SPATIAL	{ $$ = 3; }
   ;
   
opt_using_type: 
    | USING index_type
    ;
	
index_type: BTREE	{ $$ = 1; }
    | HASH			{ $$ = 2; }
	;
	
index_col_list: index_col_name
    | index_col_list ',' index_col_name
	;

index_col_name: NAME opt_length opt_asc_desc
    ;
	
	/** drop index **/
stmt: drop_index_stmt { emit("STMT"); }
    ;
	
drop_index_stmt: DROP INDEX NAME ON NAME
    ;
	
	/**	drop database **/	
stmt: drop_database_stmt { emit("STMT"); }
	;
	
drop_database_stmt: 
	DROP DATABASE opt_if_exists NAME	{ emit("DROPDATABASE %d %s", $3, $4); free($4); }
   | DROP SCHEMA opt_if_exists NAME 	{ emit("DROPSCHEMA %d %s", $3, $4); free($4); }
   ;
   
opt_if_exists: /* nil */	{ $$ = 0; }
   | IF EXISTS				{ $$ = 1; }
   ;
   
   /** drop table **/
stmt: drop_table_stmt { emit("STMT"); }

drop_table_stmt:
	DROP opt_temporary TABLE opt_if_exists table_list opt_rc	{ emit("DROP %d %d %d %d", $2, $4, $5, $6); }
	;
	
table_list: NAME 					{ emit("TABLE %s", $1);}
   | NAME'.' NAME					{ emit("TABLE %s.%s", $1, $3); }
   | table_list ',' NAME			{ emit("TABLE %s", $1);}
   | table_list ',' NAME '.' NAME	{ emit("TABLE %s.%s", $1, $3); }
   ;

opt_rc: /* nil */ 	{ $$ = 0; }
   | RESTRICT	 	{ $$ = 1; }
   | CASCADE 		{ $$ = 2; }
   ;
   
   
   /** rename table **/
stmt: rename_table_stmt { emit("STMT"); }
   ;
   
rename_table_stmt: RENAME TABLE rename_list {}
   ;
   
rename_list: 
   | NAME TO NAME{}
   | NAME '.' NAME TO NAME '.' NAME {}
   | rename_list ',' NAME TO NAME {}
   | rename_list ',' NAME '.' NAME TO NAME '.' NAME {}
   ;

     /** describe name **/
stmt: describe_stmt { emit("STMT"); }
   ;
   
describe_stmt: DESCRIBE NAME {}
   | DESC NAME {}
   ;
   
   /** use database **/
stmt: use_stmt { emit("STMT"); }
   ;
   
use_stmt: USE NAME {}
   ;
   
   /** start transaction, commit, rollback **/
stmt: start_transaction_stmt { emit("STMT"); }
   | commit_stmt { emit("STMT"); }
   | rollback_stmt { emit("STMT"); }
   ;
   
start_transaction_stmt: START TRANSACTION 
   | BEGINT opt_work
   ;
   
opt_work: /* nil */
   | WORK
   ;
   
commit_stmt: COMMIT opt_work opt_chain opt_release { emit("STMT"); }
   ;
   
 opt_chain: /* nil */	{ $$ = 0; }
   | AND NO CHAIN	{ $$ = 1; }
   | AND CHAIN	{ $$ = 2; }
   ;
   
opt_release: /* nil */	{ $$ = 0; }
   | NO RELEASE	{ $$ = 1; }
   | RELEASE	{ $$ = 2; }
   ;
   
rollback_stmt: ROLLBACK opt_work opt_chain opt_release { emit("STMT"); }
   ;
   
   /** set autocommit **/
stmt: set_autocommit_stmt { emit("STMT"); }
   ;
   
set_autocommit_stmt: SET AUTOCOMMIT COMPARISON expr
   ;
   
   /** savepoint,rollback savepoint, release savepoint **/
stmt: savepoint_stmt
   | rollback_to_savepoint_stmt
   | release_savepoint
   ;
   
   
savepoint_stmt: SAVEPOINT NAME	/* SAVEPOINT identifier */
   ;
   
rollback_to_savepoint_stmt: ROLLBACK opt_work TO SAVEPOINT NAME
   ;
   
release_savepoint: RELEASE SAVEPOINT NAME
   ;
   
   /** lock tables **/
stmt: lock_table_stmt  { emit("STMT"); }
   ;
   
lock_table_stmt: LOCK TABLES lock_table_list
   ;
   
lock_table_list: lock_table
   | lock_table_list ',' lock_table
   ;
   
lock_table: NAME opt_as_alias opt_read_write
   ;
   
opt_read_write: READ	{ $$ = 1; }
   | READ LOCAL			{ $$ = 2; }
   | LOW_PRIORITY WRITE { $$ = 3; }
   | WRITE				{ $$ = 4; }
   ;
   
   /** unlock tables **/
stmt: unlock_tables
   ;
   
unlock_tables: UNLOCK TABLES
   ;
   
   /** set transaction **/
stmt: set_transaction_stmt
   ;
   
set_transaction_stmt:
	SET opt_trans_level TRANSACTION ISOLATION LEVEL trans_att
   ;
	
opt_trans_level: /* nil */	{ $$ = 0; }
   | GLOBAL					{ $$ = 1; }
   | SESSION				{ $$ = 2; }
   ;
   
trans_att:
	READ UNCOMMITTED	{ $$ = 1; }
	| READ COMMITTED	{ $$ = 2; }
	| REPEATABLE READ	{ $$ = 3; }
	| SERIALIZABLE		{ $$ = 4; }
	;
   
   	/** create user **/
stmt: create_user_stmt { emit("STMT"); }
   ;
   
create_user_stmt: CREATE USER create_user_list
   ;

create_user_list: create_user
   | create_user_list ',' create_user
   ;
   
create_user: USERVAR
   | USERVAR IDENTIFIED BY STRING
   | USERVAR IDENTIFIED BY PASSWORD STRING
   ;
   
   /** drop user **/
stmt: drop_user_stmt { emit("STMT"); }
   ;

drop_user_stmt: DROP USER user_list
   ;
   
user_list: USERVAR
   | user_list ',' USERVAR
   ;
   
   /** grant all **/
stmt: grant_all_stmt { emit("STMT"); }
   ;
   
grant_all_stmt: GRANT priv_database_list ON '*' '.' '*' TO create_user_list opt_with_opt
	;
	
priv_database_list: priv_database_type
   | priv_database_list ',' priv_database_type
   ;
   
priv_database_type: 
	ALL		{ $$ = 01; }
   | ALL PRIVILEGES	{ $$ = 02; }
   | SELECT	{ $$ = 04; }
   | UPDATE { $$ = 010; }
   | INSERT	{ $$ = 020; }
   | DELETE	{ $$ = 040; }
   | CREATE	{ $$ = 0100; }
   | DROP	{ $$ = 0200; }
   | INDEX	{ $$ = 0400; }
   | ALTER	{ $$ = 01000; }
   | GRANT OPTION	{ $$ = 02000; }
   | REFERENCES		{ $$ = 04000; }
   ;
   
opt_with_opt: /* nil */
   | WITH with_opt
   ;
   
with_opt: 
	GRANT OPTION
   | MAX_QUERIES_PER_HOUR expr
   | MAX_UPDATES_PER_HOUR expr
   | MAX_CONNECTIONS_PER_HOUR expr
   | MAX_USER_CONNECTIONS expr
   ;
	
   /** grant database **/
stmt: grant_database_stmt { emit("STMT"); }
   ;
   
grant_database_stmt: GRANT priv_database_list ON NAME '.' '*' TO create_user_list opt_with_opt
   ;

   /** grant table **/
stmt: grant_table_stmt { emit("STMT"); }
   ;
   
grant_table_stmt: GRANT priv_table_list ON NAME '.' NAME TO create_user_list opt_with_opt
   ;
   
priv_table_list: priv_table_type
   | priv_table_list ',' priv_table_type
   ;
	
priv_table_type: 
	SELECT opt_col_names
   | UPDATE opt_col_names
   | INSERT opt_col_names
   | DELETE 
   | CREATE
   | DROP
   | INDEX
   | ALTER
   | GRANT OPTION
   ;
	/* 
	对于一个表，您可以指定的priv_type值只能是
	SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, GRANT OPTION, INDEX和ALTER。
	对于一个列（也就是，当您使用一个column_list子句时），
	您可以指定的priv_type值只能是SELECT, INSERT和UPDATE。
	*/

	/** revoke all **/
stmt: revoke_all_stmt { emit("STMT"); }
   ;
   
revoke_all_stmt: REVOKE priv_database_list ON '*' '.' '*' FROM user_list
	;
   /** revoke database **/
stmt: revoke_database_stmt  { emit("STMT"); }
   ;

revoke_database_stmt: REVOKE priv_database_list ON NAME '.' '*' FROM user_list opt_with_opt
   ;
   
stmt: revoke_table_stmt  { emit("STMT"); }
   ;

revoke_table_stmt: REVOKE priv_table_list ON NAME '.' NAME FROM user_list opt_with_opt
   ;
   
   /** rename user **/
stmt: rename_user_stmt { emit("STMT"); }
   ;
   
rename_user_stmt: RENAME USER utou_list
   ;
   
utou_list: 
	USERVAR TO USERVAR
   | utou_list ',' USERVAR TO USERVAR
   ;
   
   /** set password **/
stmt: set_password_stmt { emit("STMT"); }
   ;
   
set_password_stmt: SET PASSWORD opt_for_user COMPARISON PASSWORD '(' STRING ')'
   ;
   
opt_for_user: /* nil */
   | FOR USERVAR
   ;
   
   /** analyze table**/
stmt: analyze_table_stmt { emit("STMT"); }
   ;
   
analyze_table_stmt: ANALYZE analyze_opt TABLE table_list
   ;
   
analyze_opt: /* nil */	{ $$ = 0; }
   | LOCAL	{ $$ = 1; }
   | NO_WRITE_TO_BINLOG	{ $$ = 2; }
   ;
   
   /** backup table **/
stmt: backup_table_stmt { emit("STMT"); }
   ;
   
backup_table_stmt: BACKUP TABLE table_list TO STRING
   ;
   
   /** check table **/
stmt: check_table_stmt { emit("STMT"); }
   ;
   
check_table_stmt: CHECK TABLE table_list check_opts
   ;
   
check_opts: /* nil */	{ $$ = 0; }
   | QUICK	{ $$ = 1; }
   | FAST	{ $$ = 2; }
   | MEDIUM	{ $$ = 3; }
   | EXTENDED	{ $$ = 4; }
   | CHANGED	{ $$ = 5; }
   ;
   
   /** checksum table **/
stmt: checksum_table_stmt { emit("STMT"); }
   ;
   
checksum_table_stmt: CHECKSUM TABLE table_list checksum_opt
   ;
   
checksum_opt: /* nil */	{ $$ = 0; }
   | QUICK	{ $$ = 1; }
   | EXTENDED	{ $$ = 2; }
   ;
   
   /** optimize table **/
stmt: optimize_table_stmt { emit("STMT"); }
   ;
   
optimize_table_stmt: OPTIMIZE analyze_opt TABLE table_list
   ;
    
	/** repair table **/
stmt: repair_table_stmt { emit("STMT"); }
   ;
   
repair_table_stmt: REPAIR analyze_opt TABLE table_list repair_opts
   ;
   
repair_opts: /* nil */
   | repair_opts QUICK
   | repair_opts EXTENDED
   | repair_opts USE_FRM
   ;
   
	/** restore table **/
stmt: restore_table_stmt { emit("STMT"); }
   ;
   
restore_table_stmt: RESTORE TABLE table_list FROM STRING
   ;
   
   /** show statement **/
stmt: show_stmt
   ;
   
show_stmt: SHOW CHARACTER SET opt_like_string
   | SHOW COLLATION opt_like_string
   | SHOW opt_full COLUMNS FROM NAME opt_from opt_like_string
   | SHOW CREATE DATABASE NAME
   | SHOW CREATE SCHEMA NAME
   | SHOW CREATE TABLE NAME
   | SHOW DATABASE NAME
   | SHOW SCHEMA NAME 
   | SHOW ENGINE NAME LOGS
   | SHOW ENGINE NAME STATUS
   | SHOW STORAGE ENGINES
   | SHOW ERRORS opt_limit
   | SHOW expr ERRORS  /* expr = COUNT(*) */
   | SHOW GRANTS FOR USERVAR
   | SHOW INDEX FROM NAME opt_from
   | SHOW INNODB STATUS
   | SHOW opt_bdb LOGS
   | SHOW OPEN TABLES opt_from opt_like_string
   | SHOW PRIVILEGES
   | SHOW opt_full PROCESSLIST
   | SHOW opt_trans_level STATUS opt_like_string
   | SHOW TABLE STATUS opt_from opt_like_string
   | SHOW opt_full TABLES opt_from opt_like_string
   | SHOW TRIGGERS opt_from opt_like_expr
   | SHOW opt_trans_level VARIABLES opt_like_string
   | SHOW WARNINGS opt_limit
   | SHOW expr WARNINGS /* expr = COUNT(*) */
   ;
   
opt_full: /* nil */	{ $$ = 0; }
   | FULL	{ $$ = 1; }
   ;
   
opt_from: /* nil */
   | FROM NAME
   ;
   
opt_like_string: /* nil */
   | LIKE STRING
   ;
   
opt_like_expr: /* nil */
   | LIKE expr
   ;
   
opt_bdb: /* nil */
   | BDB
   ;
   
   /* cache index */
stmt: cache_index_stmt
   ;
   
cache_index_stmt: CACHE INDEX  table_index_list IN NAME
   ;
   
table_index_list: table_index
   | table_index_list ',' table_index
   ;
   
table_index: NAME
   | NAME opt_index_key index_list
   ;
   
opt_index_key: /* nil */	{ $$ = 0; }
   | INDEX	{ $$ = 1; }
   | KEY	{ $$ = 2; }
   ;
   
   /* flush statement */
stmt: flush_stmt
   ;
   
flush_stmt: FLUSH analyze_opt flush_opt_list
   ;
   
flush_opt_list: flush_opt
   | flush_opt_list ',' flush_opt
   ;
   
flush_opt: HOSTS	{ $$ = 1; }
   | DES_KEY_FILE	{ $$ = 2; }
   | LOGS			{ $$ = 04; }
   | PRIVILEGES		{ $$ = 010; }
   | QUERY CACHE	{ $$ = 020; }
   | STATUS			{ $$ = 040; }
   | TABLE NAME		{ $$ = 0100; }
   | TABLES table_list		{ $$ = 0200; }
   | TABLES WITH READ LOCK	{ $$ = 0400; }
   | USER_RESOURCES			{ $$ = 01000; }
   ;
   
   /* kill statement */
stmt: kill_stmt
   ;
   
kill_stmt: KILL opt_connection_query expr
   ;
   
opt_connection_query: /* nil */	{ $$ = 0; }
   | CONNECTION	{ $$ = 1; }
   | QUERY		{ $$ = 2; }
   ;
   
   /** load index into cache **/
stmt: load_index_stmt
   ;
   
load_index_stmt: LOAD INDEX INTO CACHE table_index_list
   ;
   
table_index_list: NAME opt_index_key_list opt_ignore_leaves
   ;
   
opt_index_key_list: opt_index_key '(' index_list ')'
   ;
   
opt_ignore_leaves: /* nil */
   | IGNORE LEAVES
   ;
   
   /** reset statement **/
stmt: reset_stmt
   ;
   
reset_stmt: RESET reset_opt_list
   ;
   
reset_opt_list: reset_opt
   | reset_opt_list ',' reset_opt
   ;
   
reset_opt: MASTER	{ $$ = 1; }
   | QUERY CACHE	{ $$ = 2; }
   | SLAVE			{ $$ = 3; }
   ;
   
   /** prepare statement **/
stmt: prepare_stmt
   ;
   
prepare_stmt: PREPARE NAME FROM stmt
   | EXECUTE NAME opt_use_name
   | DEALLOCATE PREPARE NAME
   | DROP PREPARE NAME
   ;

opt_use_name: /* nil */
   | USING user_list
   ;

expr: '?'
   ;
   
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
    
   /**** set user variables ****/

stmt: set_stmt { emit("STMT"); }
   ;

set_stmt: SET set_list ;

set_list: set_expr | set_list ',' set_expr ;

set_expr:
	USERVAR COMPARISON expr 
	{ if ($2 != 4) yyerror("bad set to @%s", $1);
		emit("SET %s", $1); free($1);
	}
    | USERVAR ASSIGN expr 
    {
    	emit("SET %s", $1); 
    	free($1); 
    }
    ;
    

opt_length: /* nil */		{ $$ = NULL; }
   | '(' INTNUM ')' 		{ $$ = newLength (t_length, $2, 0); }
   | '(' INTNUM ',' INTNUM ')'	{ $$ = newLength (t_length, $2, $4); }
   ;

opt_binary: /* nil */	{ $$ = 0; }
   | BINARY		{ $$ = 1; }
   ;

opt_uz: /* nil */ 	{ $$ = 0; }
   | opt_uz UNSIGNED	{ $$ = $1 | 01; }
   | opt_uz ZEROFILL	{ $$ = $1 | 02; }
   ;

opt_csc: /* nil */		{ $$ =newOptCsc(t_opt_csc, 0, NULL, NULL);}
   | opt_csc CHAR SET NAME	/* 最先是char set string，后改为name */
		{ Opt_csc * t = (Opt_csc *)$1; t->datatype = t->datatype | 01; t->s1 = $4; $$ = (Node *)t; }
   | opt_csc COLLATE NAME	
		{ Opt_csc * t = (Opt_csc *)$1; t->datatype = t->datatype | 02; t->s2 = $3; $$ = (Node *)t; }
   ;

data_type:
   BIT opt_length			{ $$ = newDatatype (t_datatype, 01, $2, 0, NULL, 0, NULL); }
   | TINYINT opt_length opt_uz 		{ $$ = newDatatype (t_datatype, 02, $2, $3, NULL, 0, NULL); }
   | SMALLINT opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 04, $2, $3, NULL, 0, NULL); }
   | MEDIUMINT opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 010, $2, $3, NULL, 0, NULL); }
   | INT opt_length opt_uz		{ $$ = newDatatype (t_datatype, 020, $2, $3, NULL, 0, NULL); }
   | INTEGER opt_length opt_uz		{ $$ = newDatatype (t_datatype, 040, $2, $3, NULL, 0, NULL); }
   | BIGINT opt_length opt_uz	{ $$ = newDatatype (t_datatype, 0100, $2, $3, NULL, 0, NULL); }
   | REAL opt_length opt_uz	{ $$ = newDatatype (t_datatype, 0200, $2, $3, NULL, 0, NULL); }
   | DOUBLE opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 0400, $2, $3, NULL, 0, NULL); }
   | FLOAT opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 01000, $2, $3, NULL, 0, NULL); }
   | DECIMAL opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 02000, $2, $3, NULL, 0, NULL); }
   | DATE 			{ $$ = newDatatype (t_datatype, 04000, NULL, 0, NULL, 0, NULL); }
   | TIME			{ $$ = newDatatype (t_datatype, 010000, NULL, 0, NULL, 0, NULL); }
   | TIMESTAMP			{ $$ = newDatatype (t_datatype, 020000, NULL, 0, NULL, 0, NULL); }
   | DATETIME 			{ $$ = newDatatype (t_datatype, 040000, NULL, 0, NULL, 0, NULL); }
   | YEAR 			{ $$ = newDatatype (t_datatype, 0100000, NULL, 0, NULL, 0, NULL); }
   | CHAR opt_length opt_csc 	{ $$ = newDatatype (t_datatype, 0200000, $2, 0, $3, 0, NULL); }
   | VARCHAR '(' INTNUM ')' opt_csc	{ Node * t = newLength(t_datatype, $3, NULL);
					$$ = newDatatype (t_datatype, 0400000, t, 0, $5, 0, NULL); }
   | BINARY opt_length 		{ $$ = newDatatype (t_datatype, 01000000, $2, 0, NULL, 0, NULL); }
   | VARBINARY '(' INTNUM ')' 	{  Node * t = newLength(t_datatype, $3, NULL);
				$$ = newDatatype (t_datatype, 02000000, NULL, 0, NULL, 0, NULL); }
   | TINYBLOB 			{ $$ = newDatatype (t_datatype, 04000000, NULL, 0, NULL, 0, NULL); }
   | BLOB 			{ $$ = newDatatype (t_datatype, 010000000, NULL, 0, NULL, 0, NULL); }
   | MEDIUMBLOB			{ $$ = newDatatype (t_datatype, 020000000, NULL, 0, NULL, 0, NULL); }
   | LONGBLOB			{ $$ = newDatatype (t_datatype, 040000000, NULL, 0, NULL, 0, NULL); }
   | TINYTEXT opt_binary opt_csc{ $$ = newDatatype (t_datatype, 0100000000, NULL, 0, $3, $2, NULL); }
   | TEXT opt_binary opt_csc 	{ $$ = newDatatype (t_datatype, 0200000000, NULL, 0, $3, $2, NULL); }
   | MEDIUMTEXT opt_binary opt_csc{ $$ = newDatatype (t_datatype, 0400000000, NULL,0, $3, $2, NULL); }
   | LONGTEXT opt_binary opt_csc  { $$ = newDatatype (t_datatype, 01000000000,NULL,0, $3, $2, NULL); }
   | ENUM '(' enum_list ')' opt_csc{ $$ = newDatatype (t_datatype, 02000000000, NULL, 0, $5, 0, $3); }
   | SET '(' enum_list ')' opt_csc { $$ = newDatatype (t_datatype, 04000000000, NULL, 0, $5, 0, $3); }
   ;

enum_list: STRING 		{ $$ = newEnumList( t_enum_list, $1, NULL); }
   | enum_list ',' STRING	{ $$ = newEnumList( t_enum_list, $3, $1); }
   ;


   /**** expressions ****/

expr: NAME         { dataval d; d.string_val = $1; $$ = newExpr(t_name, d);  puts("expr1");}
   | USERVAR       { dataval d; d.string_val = $1; $$ = newExpr(t_name, d); }
   | NAME '.' NAME { $$ = newColumn(t_name_name, $1, $3, NULL); puts("expr2");}
   | STRING        { dataval d; d.string_val = $1; $$ = newExpr(t_stringval, d); puts("expr3");}
   | INTNUM        { dataval d; d.int_val=$1; $$ = newExpr(t_intnum, d); puts("expr4");}
   | APPROXNUM     { dataval d; d.double_val = $1; $$ = newExpr(t_approxnum, d); }
   | BOOL          { dataval d; d.bool_val = $1; $$ = newExpr(t_bool, d); }
   ;

expr: expr '+' expr { $$=newExprCal(t_expr_cal, "+", NULL, 0, $1, $3); }
   | expr '-' expr  { $$=newExprCal(t_expr_cal, "-", NULL, 0, $1, $3); }
   | expr '*' expr  { $$=newExprCal(t_expr_cal, "*", NULL, 0, $1, $3); }
   | expr '/' expr 	{ $$=newExprCal(t_expr_cal, "/", NULL, 0, $1, $3); }
   | expr '%' expr 	{ $$=newExprCal(t_expr_cal, "%", NULL, 0, $1, $3); }
   | expr MOD expr 	{ $$=newExprCal(t_expr_cal, "MOD", NULL, 0, $1, $3); }
   | '-' expr %prec UMINUS	{ $$=newExprCal(t_expr_cal, "--", NULL, 0, NULL, $2); }
   | expr ANDOP expr	{ $$=newExprCal(t_expr_cal, "ANDOP", NULL, 0, $1, $3); }
   | expr OR expr	{ $$=newExprCal(t_expr_cal, "OR", NULL, 0, $1, $3); }
   | expr XOR expr	{ $$=newExprCal(t_expr_cal, "XOR", NULL, 0, $1, $3); }
   | expr COMPARISON expr	{ $$ = newExprCal(t_expr_cal, "CMP", NULL, $2, $1, $3);/* puts("=");*/ }
   | expr COMPARISON '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", NULL, $2, $1, $4); }
   | expr COMPARISON ANY '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", "ANY", $2, $1, $5); }
   | expr COMPARISON SOME '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", "SOME", $2, $1, $5); }
   | expr COMPARISON ALL '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", "ALL", $2, $1, $5); }
   | expr '|' expr	{ $$=newExprCal(t_expr_cal, "|", NULL, 0, $1, $3); }
   | expr '&' expr	{ $$=newExprCal(t_expr_cal, "&", NULL, 0, $1, $3); }
   | expr '^' expr	{ $$=newExprCal(t_expr_cal, "^", NULL, 0, $1, $3); }
   | expr SHIFT expr	{ $$=newExprCal(t_expr_cal, (SHIFT==1?"LS":"RS"), NULL, 0, $1, $3); }
   | NOT expr %dprec 1	{ $$=newExprCal(t_expr_cal, "NOT", NULL, 0, NULL, $2); }
   | '!' expr	{ $$=newExprCal(t_expr_cal, "!", NULL, 0, NULL, $2); }
   | USERVAR ASSIGN expr	{ $$=NULL; }////////////////////////////////////////////////////////////////////////////////////
   | '(' expr ')'	{ $$ = $2; }
   ;    

expr:  expr IS NULLX     { $$=newExprFunc(t_expr_func, "ISN", $1, NULL, NULL, NULL); }
   |   expr IS NOT NULLX { $$=newExprFunc(t_expr_func, "ISNN", $1, NULL, NULL, NULL); }
   |   expr IS BOOL      { $$=newExprFunc(t_expr_func, "ISB", $1, NULL, NULL, NULL); }
   |   expr IS NOT BOOL  { $$=newExprFunc(t_expr_func, "ISNB", $1, NULL, NULL, NULL); }
   ;

expr: expr BETWEEN expr AND expr %prec BETWEEN { $$=newExprFunc(t_expr_func, "BA", $1, $3, $5, NULL); }
   ;


expr_list: expr	{ $$ = newExprList(t_expr_list, $1, NULL); }
   | expr ',' expr_list { $$ = newExprList(t_expr_list, $1, $3); }
   ;

opt_expr_list: /* nil */
   | expr_list {$$=$1;}
   ;

expr: expr IN '(' expr_list ')'		{ $$=newExprCal(t_expr_cal, "INV", NULL, 0, $1, $4); }
   | expr NOT IN '(' expr_list ')'	{ $$=newExprCal(t_expr_cal, "NIN", NULL, 0, $1, $5); }
   | expr IN '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "INS", NULL, 0, $1, $4); }
   | expr NOT IN '(' select_stmt ')'{ $$=newExprCal(t_expr_cal, "NINS", NULL, 0, $1, $5); }
   | EXISTS '(' select_stmt ')'		{ $$=newExprCal(t_expr_cal, "EX", NULL, 0, NULL, $3); }         
   | NOT EXISTS '(' select_stmt ')'	%dprec 2	{ $$=newExprCal(t_expr_cal, "NINS", NULL, 0, NULL, $4); } 
   ;

expr: NAME '(' opt_expr_list ')'	{ $$=newExprCal(t_expr_cal, "NAME", $1, 0, NULL, $3); }   
   ;

  /* functions with special syntax */
expr: FCOUNT '(' '*' ')'	{ $$=newExprFunc(t_expr_func, "FCOUNTALL", NULL, NULL, NULL, NULL); }
   | FCOUNT '(' expr ')'	{ $$=newExprFunc(t_expr_func, "FCOUNT", NULL, $3, NULL, NULL); }
   ;
   
expr: FSUBSTRING '(' expr_list ')'	{ $$=newExprFunc(t_expr_func, "FSUBSTRING", NULL, $3, NULL, NULL); }
   | FSUBSTRING '(' expr FROM expr ')'	{ $$=newExprFunc(t_expr_func, "FSUBSTRING2", NULL, $3, $5, NULL);}
   | FSUBSTRING '(' expr FROM expr FOR expr ')' { $$=newExprFunc(t_expr_func, "FSUBSTRING3", $7, $3, $5, NULL); }
   | FTRIM '(' expr_list ')' { $$=newExprFunc(t_expr_func, "FTRIM", NULL, $3, NULL, NULL); }
   | FTRIM '(' trim_ltb expr FROM expr_list ')'	{ }//////////////////////////////////////////////////////////////////////////////
   ;

trim_ltb: LEADING  { emit("INT 1"); }
   | TRAILING { emit("INT 2"); }
   | BOTH { emit("INT 3"); }
   ;

expr: FDATE_ADD '(' expr ',' interval_exp ')' //71{ emit("CALL 3 DATE_ADD"); }
   |  FDATE_SUB '(' expr ',' interval_exp ')' //72{ emit("CALL 3 DATE_SUB"); }
   ;

interval_exp: INTERVAL expr DAY_HOUR { emit("NUMBER 1"); }
   | INTERVAL expr DAY_MICROSECOND { emit("NUMBER 2"); }
   | INTERVAL expr DAY_MINUTE { emit("NUMBER 3"); }
   | INTERVAL expr DAY_SECOND { emit("NUMBER 4"); }
   | INTERVAL expr YEAR_MONTH { emit("NUMBER 5"); }
   | INTERVAL expr YEAR       { emit("NUMBER 6"); }
   | INTERVAL expr HOUR_MICROSECOND { emit("NUMBER 7"); }
   | INTERVAL expr HOUR_MINUTE { emit("NUMBER 8"); }
   | INTERVAL expr HOUR_SECOND { emit("NUMBER 9"); }
   ;
	
expr: CASE expr case_list END			{ $$=newExprFunc(t_expr_func, "CASE3", $2, $3, NULL, NULL); }
   |  CASE expr case_list ELSE expr END	{ $$=newExprFunc(t_expr_func, "CASE2", $2, $3, $5, NULL); }
   |  CASE case_list END                { $$=newExprFunc(t_expr_func, "CASE3", NULL, $2, NULL, NULL); }
   |  CASE case_list ELSE expr END      { $$=newExprFunc(t_expr_func, "CASE4", NULL, $2, $4, NULL); }
   ;

case_list: WHEN expr THEN expr		{ $$=newExprFunc(t_expr_func, "WHEN1", NULL, $2, $4, NULL); }
   | case_list WHEN expr THEN expr	{ $$=newExprFunc(t_expr_func, "WHEN2", NULL, $3, $5, $1); }
   ;

expr: expr LIKE expr	{ $$=newExprCal(t_expr_cal, "LIKE", NULL, 0, $1, $3); }
   | expr NOT LIKE expr { $$=newExprCal(t_expr_cal, "NLIKE", NULL, 0, NULL, $4); }
   ;

expr: expr REGEXP expr		{ $$=newExprCal(t_expr_cal, "REGEXP", NULL, 0, $1, $3); }
   | expr NOT REGEXP expr	{ $$=newExprCal(t_expr_cal, "NREGEXP", NULL, 0, $1, $4); }
   ;

expr: CURRENT_TIMESTAMP //85{ emit("NOW") };
   | CURRENT_DATE	//86{ emit("NOW") };
   | CURRENT_TIME	//87{ emit("NOW") };
   ;

expr: BINARY expr %prec UMINUS //88{ emit("STRTOBIN"); }
   ;

%%

void
emit(char *s, ...)
{
  extern int yylineno;

  va_list ap;
  va_start(ap, s);

  printf("rpn: ");
  vfprintf(stdout, s, ap);
  printf("\n");
}

void
yyerror(const char *s, ...)
{
  extern int  yylineno;

  va_list ap;
  va_start(ap, s);

  fprintf(stderr, "%d: error: ", yylineno);
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");
}

/*
int readInputForLexer( char *buffer, int *numBytesRead, int maxBytesToRead ) {
	int numBytesToRead = maxBytesToRead;
	int bytesRemaining = strlen(globalInputText)-globalReadOffset;
	int i;
	if ( numBytesToRead > bytesRemaining ) { numBytesToRead = bytesRemaining; }
	for ( i = 0; i < numBytesToRead; i++ ) {
		buffer[i] = globalInputText[globalReadOffset+i];
	}
	*numBytesRead = numBytesToRead;
	globalReadOffset += numBytesToRead;
	cout<<isfirst<<endl;
	if (!isfirst)
	{
		pthread_mutex_unlock(&mutex);
		isfirst = !isfirst;
	}
	return 0;
}*/

/*
main(int ac, char **av)
{
	char c;
	while(1)
	{
		int charnum=0;
	    	while(1)
	    	{
			char c=getchar();
			globalInputText[charnum++] = c;
			if(c==';')
			{
			    globalInputText[charnum++]='\0';
			    break;
			}
	  	}
	    	puts(globalInputText);
	
		numToRead = strlen(globalInputText);
	
		if(!yyparse())
		{
			printf("SQL parse worked\n");
		}		
		else
		{
			printf("SQL parse failed\n");
		}
		c = getchar();
		while(c != '\n')
		{
			c = getchar();
		}
		cout<<"q for quit, other for continue"<<endl;
		c = getchar();
		cout<<c<<endl;
		if(c == 'q') break;
	}
} *//* main */
